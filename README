Canvas filters
--------------

This library implements a few image processing filters using the canvas element.

The filters operate on ImageData objects. The filters do not modify the source ImageData.

Based on http://www.html5rocks.com/en/tutorials/canvas/imagefilters/

API Documentation
-----------------

Filters : {
	//
	// Convenience functions
	//
	
	// filterImage applies a filter function to an image or canvas element.
	// Arguments from the third onwards are passed as extra arguments to the filter function.
	ImageData filterImage(Function filter, Image_or_Canvas image, Filter_arguments var_args, ...)

	// getPixels returns the ImageData object for an image or a canvas element.
	ImageData getPixels(Image_or_Canvas img)
	
	// toCanvas returns a new canvas filled with the given ImageData object.
	Canvas toCanvas(ImageData pixels)
	
	// getCanvas creates a canvas of the wanted dimensions
	Canvas getCanvas(int width, int height)
	
	// createImageData creates an ImageData object of the wanted dimensions
	ImageData createImageData(int width, int height)

        // bilinearSample bilinearly samples the image at the given coordinates.
        // The result is computed by linear blending of the four pixels around x,y.
        [r,g,b,a] bilinearSample(ImageData pixels, float x, float y)
	
	//
	// Filters
	// 
	
	// identity returns a copy of the ImageData
	ImageData identity(ImageData pixels)
	
	// luminance converts the image to grayscale using the CIE luminance 
	// (0.2126*r + 0.7152*g + 0.0722*b)
	ImageData luminance(ImageData pixels)

	// grayscale converts the image to grayscale using  
	// (0.3*r + 0.59*g + 0.11*b)
	ImageData grayscale(ImageData pixels)

	// grayscaleAvg converts the image to grayscale using  
	// (r+g+b) / 3
	ImageData grayscaleAvg(ImageData pixels)

	// desaturate desaturates image by the given factor.
	// It uses the grayscale factors for the grayscale value.
	ImageData desaturate(ImageData pixels, float factor)
	
	// threshold converts the image to a two-color image with
	// pixels brighter than or equal to the threshold value rendered white and 
	// pixels darker than the threshold rendered black
	// The filter uses grayscale to compute the value of a pixel.
	// (0.3*r + 0.59*g + 0.11*b)
	ImageData threshold(ImageData pixels, int threshold)
	
	// invert inverts the RGB channels of the image.
	// The inverted version of a pixel is [255-r, 255-g, 255-b, a]
	ImageData invert(ImageData pixels)

	// convolve convolves the image using the weights array as a square
	// row-major convolution matrix. If the opaque argument is set to true
	// the result image will have an opaque alpha channel.
	ImageData convolve(ImageData pixels, Array weights, bool opaque)

	// convolveFloat32 is a version of convolve that operates on ImageData-like
	// objects with a Float32Array storing the pixels
	// {width:int, height:int, data:Float32Array}. 
	// Useful when you need a high value range or negative values in pixels.  
	Float32ImageData convolveFloat32(ImageData pixels, Array weights, bool opaque)

	// gaussian5 applies a 5x5 gaussian blur kernel on the image.
	ImageData gaussian5(ImageData pixels)
	
	// gaussian3 applies a 3x3 gaussian blur kernel on the image.
	ImageData gaussian3(ImageData pixels)
	
	// laplace applies a Laplace edge detection kernel on the image.
	ImageData laplace(ImageData pixels)
	
	// sobel applies a Sobel filter on the image.
	// This filter is purely for looks, the red channel encodes absolute vertical gradient
	// and the green channel absolute horizontal gradient.
	ImageData sobel(ImageData pixels)

	// sobelVectors computes the signed horizontal and vertical gradients of the image
	// and returns the array of resulting 2-vectors, packed tightly into a Float32Array
	Float32Vec2ImageData sobelVectors(ImageData pixels)
	
	// sobelVerticalGradient computes the signed vertical gradient of the image
	Float32ImageData sobelVerticalGradient(ImageData pixels)
	
	// sobelHorizontalGradient computes the signed horizontal gradient of the image
	Float32ImageData sobelHorizontalGradient(ImageData pixels)

        // distortSine distorts the image by pinching / punching it by the given amount.
        // The distort amounts should be between -0.5 and 0.5.
	ImageData distortSine(ImageData pixels, float xAmount, float yAmount)
	
	// darkenBlend blends b on top of a, replacing a with b whenever b is darker.
	// The filter operates on a per-channel basis, the result pixels
	// are computed as [min(a.r, b.r), min(a.g, b.g), min(a.b, b.b), alpha(a.a, b.a)]
        // where alpha(a, b) = a + (255-a)*b/255.
	ImageData darkenBlend(ImageData a, ImageData b)
	
	// lightenBlend blends b on top of a, replacing a with b whenever b is lighter.
	// The filter operates on a per-channel basis, the result pixels
	// are computed as [max(a.r, b.r), max(a.g, b.g), max(a.b, b.b), alpha(a.a, b.a)]
        // where alpha(a, b) = a + (255-a)*b/255.
	ImageData lightenBlend(ImageData a, ImageData b)

        // addBlend blends b on top of a, adding b's values to a.
        // [a.r+b.r, a.g+b.g, a.b+b.b, alpha(a.a, b.a)]
        // where alpha(a, b) = a + (255-a)*b/255.
	ImageData addBlend(ImageData a, ImageData b)

        // subBlend blends b on top of a, subtracting b's values to a.
        // [a.r-(255-b.r), a.g-(255-b.g), a.b-(255-b.b), alpha(a.a, b.a)]
        // where alpha(a, b) = a + (255-a)*b/255.
	ImageData subBlend(ImageData a, ImageData b)

        // multiplyBlend blends b on top of a, multiplying b with a.
        // [a.r*b.r/255, a.g*b.g/255, a.b*b.b/255, alpha(a.a, b.a)]
        // where alpha(a, b) = a + (255-a)*b/255.
	ImageData multiplyBlend(ImageData a, ImageData b)

        // screenBlend blends b on top of a with the screen blend mode.
        // Makes a brighter by an amount determined by b.
        // [255 - (255 - b.c)*(255 - a.c)/255, ...,  alpha(a.a, b.a)]
        // where alpha(a, b) = a + (255-a)*b/255.
	ImageData screenBlend(ImageData a, ImageData b)

        // differenceBlend blends b on top of a by taking the absolute difference
        // between the images.
        // [Math.abs(a.c-b.c), alpha(a.a, b.a)]
        // where alpha(a, b) = a + (255-a)*b/255.
	ImageData differenceBlend(ImageData a, ImageData b)
	
}
